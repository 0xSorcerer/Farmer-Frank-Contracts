// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./other/ERC721.sol";
import "./other/Ownable.sol";
import "./libraries/SafeMath.sol";
import "./libraries/Address.sol";
import "./interfaces/IBondManager.sol";

/// @title ERC721 implementation of Farmer Frank NFT Bonds (Perpetuities). 
/// @author @0xSorcerer

/// Users are not supposed to interract with this contract. Most functions are marked
/// as onlyOwner, where the contract owner will be a BondManager contract. Users will use the BondManager
/// contract to mint and claim, which will call functions within this contract.
/// This contract holds Bond Data.

contract fNFTBond is ERC721, Ownable {

    using SafeMath for uint256;
    using Address for address;

    /// @notice Info of each fNFT Bond.
    struct Bond {
        // Unique fNFT Bond ID.
        uint256 bondID;
        // Unique fNFT Bond level hex ID.
        bytes4 levelID;
        // Metrics utilized to calculate bond's underlying shares.
        uint256 index;
        // Discount percentage at which bond was purchased.
        uint256 discount;
    }

    /// @notice Bond manager interface.
    IBondManager public bondManager;

    /// @dev Precision constants.
    uint256 private constant PRECISION = 1e18;

    /// @dev Mapping storing all bond objects.
    mapping(uint256 => Bond) private bonds; 

    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}

    /// @notice Modifier ensuring that a bond with ID: _bondID exists.
    /// @notice Unique fNFT Bond ID. 
    modifier onlyIfExists(uint256 bondID) {
        require(_exists(bondID), "Bond Manager: Bond ID does not exist.");
        _;
    }

    /// @notice Get bond object at bondID.
    /// @param bondID Unique fNFT Bond ID.
    /// @return bond Returns unique fNFT bond object. 
    function getBond(uint256 bondID) external view onlyIfExists(bondID) returns (Bond memory bond) {
        bond = bonds[bondID];
    }

    /// @notice Get array of all bonds owned by user. 
    /// @param user Account whose Bonds' IDs will be returned.
    function getBondsIDsOf(address user) external view returns (uint256[] memory) {
        uint256 _balance = balanceOf(user);
        uint256[] memory IDs = new uint256[](_balance);
        for (uint256 i = 0; i < _balance; i++) {
            IDs[i] = (tokenOfOwnerByIndex(user, i));
        }

        return IDs;
    }

    /// @notice Get token URI
    /// @param bondID Unique fNFT Bond ID. 
    /// @dev Each bond level differs in URI image link, thus the tokenURI is generated by appending the hex levelID to the baseURI.
    function tokenURI(uint256 bondID) public view virtual override onlyIfExists(bondID) returns (string memory) {
        string memory base = baseURI();
        return string(abi.encodePacked(base, "/", iToHex(abi.encodePacked(bonds[bondID].levelID))));
    }

    /// @notice Used to parse bytes4 levelID to string in order to generate tokenURI. 
    /// @param buffer levelID bytes buffer.
    function iToHex(bytes memory buffer) internal pure returns (string memory) {
        bytes memory converted = new bytes(buffer.length * 2);

        bytes memory _base = "0123456789abcdef";

        for (uint256 i = 0; i < buffer.length; i++) {
            converted[i * 2] = _base[uint8(buffer[i]) / _base.length];
            converted[i * 2 + 1] = _base[uint8(buffer[i]) % _base.length];
        }

        return string(abi.encodePacked("0x", converted));
    }

    /// @notice Connect fNFTBond contract (this) to its manager.
    /// @param manager Bond Manager contract address.
    function setBondManager(address manager) external onlyOwner {
        bondManager = IBondManager(manager);
    }

    /// @notice Function called by BondManager. Mints fNFT Bond (ERC721).
    /// @param user Account receiving bond.
    /// @param levelID Bond level hex ID.
    /// @param index Metrics utilized to calculate bond's underlying shares.
    /// @param discount Discount percentage at which bond was purchased.
    function mintBonds(address user, bytes4 levelID, uint256 index, uint256 amount, uint256 discount) external {
        for (uint i = 0; i < amount; i++) {
            uint256 bondID = totalSupply();

            bonds[bondID] = Bond({
                bondID: bondID,
                levelID: levelID,
                index: index,
                discount: discount
            });

            _mint(user, bondID);
        }
    }

    /// @notice Change bond index upon transfer.
    /// @param bondID Unique fNFT Bond ID.
    /// @param index New bond index.
    function setBondIndex(uint256 bondID, uint256 index) external onlyOwner {
        bonds[bondID].index = index;
    }

    /// @notice Function called by BondManager. Set base URI for fNFT Bond contract.
    /// @param baseURI New base URI.
    function setBaseURI(string memory baseURI) external onlyOwner {
        _setBaseURI(baseURI);
    }

    /// @dev See {IERC721-safeTransferFrom}.
    /// @dev Overridden to reset Bond earned value.
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");

        if(from != to) {
            bondManager.dataTransfer(from, to, tokenId);
        }
        
        _safeTransfer(from, to, tokenId, _data);
    }

    /// @dev See {IERC721-safeTransferFrom}.
    /// @dev Overridden to reset Bond earned value.
    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");

        if(from != to) {
            bondManager.dataTransfer(from, to, tokenId);
        }
        
        _safeTransfer(from, to, tokenId, "");
    }

    /// @notice See {IERC721-transferFrom}.
    /// @dev Overridden to reset Bond earned value.
    function transferFrom(address from, address to, uint256 tokenId) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");

        if(from != to) {
            bondManager.dataTransfer(from, to, tokenId);
        }
      
        _transfer(from, to, tokenId);
    }

        
}
