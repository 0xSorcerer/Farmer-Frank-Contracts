// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./other/ERC721.sol";
import "./other/Ownable.sol";
import "./libraries/SafeMath.sol";
import "./libraries/Address.sol";
import "./interfaces/IBondManager.sol";

/// @title ERC721 implementation for Farmer Frank NFT Bonds (Perpetuities). 
/// @author @0xSorcerer

/// Users are not supposed to interract with this contract. Most functions are marked
/// as onlyOwner, where the contract owner will be a BondManager contract. Users will use the BondManager
/// contract to mint and claim, which will call the functions in this contract.
/// This contract holds Bond Data.

/// UNWEIGHTED SHARES -> Used to distribute share rewards issued to bonds.
///     At mint (no discount), unweighted shares metrics is the bond's ORIGINAL price.
///     At mint (discount), unweighted shares metrics is the bond's DISCOUNTED price.
///
/// WEIGHTED SHARES -> Used to distribute token rewards issued to bonds.
///     At mint (with and without discount), weighted shares metrics is the bond's ORIGINAL price multiplied by the bond's weight.

/// When revenue gets redistributed within FrankTreasury, a part is reinvested, and a part is rewarded as tokens to bond holders.
///     The reinvested amount is accounted for in the form of share issuance to all bonds. These issued shares are divided between bonds
///     according to their amount of unweightedShares compared to the total amount of unweightedShares. 
///
///     The tokens rewards are divided between bonds according to their amount of weightedShares compared to the total amount of weightedShares.

/// Upon claiming, the shares received by a bond will increase both its weighted shares and unweighted shares.
///     Unweighted shares will simply increase by the amount of shares received.
///     Weighted shares will increase by the amount of shares received multiplied by the bond's weight. 

contract fNFTBond is ERC721, Ownable {

    using SafeMath for uint256;
    using Address for address;

    /// @notice Info of each fNFT Bond.
    struct Bond {
        // Unique fNFT Bond ID.
        uint256 bondID;
        // Mint timestamp.
        // uint224 + bytes4 = 32 bytes -> Gas optimization.
        uint224 mint;
        // Unique fNFT Bond level hex ID.
        bytes4 levelID;
        // Amount of token rewards (not shares) earned historically when holding bond. Resets on transfer.
        uint256 earned;
        // Amount of unweighted shares.
        uint256 unweightedShares;
        // Amount of weighted shares.
        uint256 weightedShares;
        // Reward debt (token reward debt).
        uint256 rewardDebt;
        // Share debt (shares reward debt).
        uint256 shareDebt;
    }

    /// @notice Bond manager interface.
    IBondManager public BondManager;

    /// @dev Precision constants.
    uint256 private constant GLOBAL_PRECISION = 10**18;
    uint256 private constant WEIGHT_PRECISION = 100;

    /// @dev Mapping storing all bonds data.
    mapping(uint256 => Bond) private bonds; 

    event BOND_CREATED (uint256 indexed bondID, bytes4 indexed levelID, address indexed user, uint256 mint);
    event BOND_UPDATED (uint256 indexed bondID, address indexed user, uint256 newUnweightedShares, uint256 newWeightedShares);

    constructor(string memory name, string memory symbol) ERC721(name, symbol) {
        
    }

    /// @notice Modifier ensuring that a bond with ID: _bondID exists.
    /// @notice Unique fNFT Bond ID. 
    modifier onlyIfExists(uint256 bondID) {
        require(_exists(bondID), "Bond Manager: Bond ID does not exist.");
        _;
    }

    /// @notice Returns bond at _bondID.
    /// @param bondID Unique fNFT Bond ID. 
    function getBond(uint256 bondID) external view onlyIfExists(bondID) returns (Bond memory bond) {
        bond = bonds[bondID];
    }  

    /// @notice Get array of all bonds owned by user. 
    /// @param user Account whose Bonds' IDs will be returned.
    function getBondsIDsOf(address user) external view returns (uint256[] memory) {
        uint256 _balance = balanceOf(user);
        uint256[] memory IDs = new uint256[](_balance);
        for (uint256 i = 0; i < _balance; i++) {
            IDs[i] = (tokenOfOwnerByIndex(user, i));
        }

        return IDs;
    }

    /// @notice Get token URI
    /// @param bondID Unique fNFT Bond ID. 
    /// @dev Each bond level differes in URI image, thus the tokenURI is generated by appending the hex levelID to the baseURI.
    function tokenURI(uint256 bondID) public view virtual override onlyIfExists(bondID) returns (string memory) {
        string memory base = baseURI();
        return string(abi.encodePacked(base, "/", iToHex(abi.encodePacked(bonds[bondID].levelID))));
    }

    /// @notice Used to parse bytes4 levelID to string in order to generate tokenURI. 
    /// @param buffer levelID bytes buffer.
    function iToHex(bytes memory buffer) internal pure returns (string memory) {
        bytes memory converted = new bytes(buffer.length * 2);

        bytes memory _base = "0123456789abcdef";

        for (uint256 i = 0; i < buffer.length; i++) {
            converted[i * 2] = _base[uint8(buffer[i]) / _base.length];
            converted[i * 2 + 1] = _base[uint8(buffer[i]) % _base.length];
        }

        return string(abi.encodePacked("0x", converted));
    }

    /// @notice Connect fNFTBond contract (this) to its manager.
    /// @param bondManager Bond Manager contract address.
    function linkBondManager(address bondManager) external onlyOwner {
        require(bondManager != address(0), "fNFT Bond: Bond manager can't be set to the 0 address.");
        BondManager = IBondManager(bondManager);
    }

    /// @notice Function called by BondManager. Mints fNFT Bond (ERC721).
    /// @param user Account receiving bond.
    /// @param levelID Bond level hex ID.
    /// @param amount Amount of tokens that will get minted.
    /// @param weightedShares Amount of weighted shares the bond will have at mint.
    /// @param unweightedShares Amount of unweighted shares the bond will have at mint.
    function mintBonds(address user, bytes4 levelID, uint256 amount, uint256 weightedShares, uint256 unweightedShares) onlyOwner external {
        require(address(BondManager) != address(0), "fNFT Bond: BondManager isn't set.");
        
        // Calculate current debt amounts. 
        uint256 shareDebt = SafeMath.div(SafeMath.mul(unweightedShares, BondManager.accSharesPerUS()), GLOBAL_PRECISION);
        uint256 rewardDebt = SafeMath.div(SafeMath.mul(weightedShares, BondManager.accRewardsPerWS()), GLOBAL_PRECISION);
        uint224 timestamp = uint224(block.timestamp);

        for (uint i = 0; i < amount; i++) {
            uint256 bondID = totalSupply();

            // Add bond object to bonds mapping.
            bonds[bondID] = Bond({
                bondID: bondID,
                mint: timestamp,
                levelID: levelID,
                earned: 0,
                unweightedShares: unweightedShares,
                weightedShares: weightedShares,
                shareDebt: shareDebt,
                rewardDebt: rewardDebt
            });

            _safeMint(user, bondID);

            emit BOND_CREATED(bondID, levelID, user, block.timestamp);
        }
        
    }

    /// @notice Function called by BondManager. Updates bond's shares & debt at claim. 
    /// @param user Account calling the claim function from BondManager.
    /// @param bondID Unique fNFT Bond ID.
    /// @param issuedRewards Token rewards issued to bond holder.
    /// @param issuedShares Shares rewards issued to bond.
    function claim(address user, uint256 bondID, uint256 issuedRewards, uint256 issuedShares) external onlyIfExists(bondID) {
        require(address(BondManager) != address(0), "fNFT Bond: BondManager isn't set.");
        require(ownerOf(bondID) == user);

        Bond memory bond = bonds[bondID];

        bond.earned = SafeMath.add(bond.earned, issuedRewards);

        // Update shares.
        bond.unweightedShares = SafeMath.add(bond.unweightedShares, issuedShares);
        bond.weightedShares = SafeMath.add(
            bond.weightedShares,
            SafeMath.div(
                SafeMath.mul(
                    issuedShares,
                    BondManager.getBondLevel(bonds[bondID].levelID).weight
                ),
                WEIGHT_PRECISION
            )
        );

        // Update debt.
        bond.shareDebt = SafeMath.div(SafeMath.mul(bond.unweightedShares, BondManager.accSharesPerUS()), GLOBAL_PRECISION);
        bond.rewardDebt = SafeMath.div(SafeMath.mul(bond.weightedShares, BondManager.accRewardsPerWS()), GLOBAL_PRECISION);

        bonds[bondID] = bond;

        emit BOND_UPDATED(bondID, user, bond.unweightedShares, bond.weightedShares);
    }

    /// @notice Function called by BondManager. Set base URI for fNFT Bond contract.
    /// @param baseURI New base URI.
    function setBaseURI(string memory baseURI) external onlyOwner {
        _setBaseURI(baseURI);
    }

    /// @dev See {IERC721-safeTransferFrom}.
    /// @dev Overridden to reset Bond earned value.
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");

        if(from != to) {
            Bond storage _bond = bonds[tokenId];
            _bond.earned = 0;
            BondManager.setUserXP(BondManager.getUserXP(from) - BondManager.getBondLevel(bonds[tokenId].levelID).price, from);
            BondManager.setUserXP(BondManager.getUserXP(to) + BondManager.getBondLevel(bonds[tokenId].levelID).price, to);
        }

        _safeTransfer(from, to, tokenId, _data);
    }

    /// @dev See {IERC721-safeTransferFrom}.
    /// @dev Overridden to reset Bond earned value.
    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");

        if(from != to) {
            Bond storage _bond = bonds[tokenId];
            _bond.earned = 0;
            BondManager.setUserXP(BondManager.getUserXP(from) - BondManager.getBondLevel(bonds[tokenId].levelID).price, from);
            BondManager.setUserXP(BondManager.getUserXP(to) + BondManager.getBondLevel(bonds[tokenId].levelID).price, to);
        }

        _safeTransfer(from, to, tokenId, "");
    }

    /// @notice See {IERC721-transferFrom}.
    /// @dev Overridden to reset Bond earned value.
    function transferFrom(address from, address to, uint256 tokenId) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");

        if(from != to) {
            Bond storage _bond = bonds[tokenId];
            _bond.earned = 0;
            BondManager.setUserXP(BondManager.getUserXP(from) - BondManager.getBondLevel(bonds[tokenId].levelID).price, from);
            BondManager.setUserXP(BondManager.getUserXP(to) + BondManager.getBondLevel(bonds[tokenId].levelID).price, to);
        }

        _transfer(from, to, tokenId);
    }
}
